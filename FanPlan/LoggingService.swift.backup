//
//  LoggingService.swift
//  PiggyBong
//

import Foundation

// MARK: - Production-Ready Logging Service
class LoggingService {
    static let shared = LoggingService()
    
    private let subsystem = "com.piggybong.app"
    
    // Log categories for better organization
    enum Category: String, CaseIterable {
        case authentication = "Authentication"
        case database = "Database"
        case network = "Network"
        case ui = "UserInterface"
        case security = "Security"
        case performance = "Performance"
        case general = "General"
        
        var name: String {
            return self.rawValue
        }
    }
    
    enum LogLevel: String, CaseIterable {
        case debug = "DEBUG"
        case info = "INFO"
        case warning = "WARNING"
        case error = "ERROR"
        case critical = "CRITICAL"
        
        var emoji: String {
            switch self {
            case .debug: return "üîç"
            case .info: return "‚ÑπÔ∏è"
            case .warning: return "‚ö†Ô∏è"
            case .error: return "‚ùå"
            case .critical: return "üö®"
            }
        }
    }
    
    private init() {}
    
    // MARK: - Logging Methods
    
    func log(_ level: LogLevel, category: Category, message: String, file: String = #file, function: String = #function, line: Int = #line) {
        let fileName = URL(fileURLWithPath: file).lastPathComponent
        let logMessage = "[\(fileName):\(line)] \(function) - \(message)"
        
        // Simple console logging
        #if DEBUG
        print("üê∑ \(level.emoji) [\(level.rawValue)] [\(category.name)] \(logMessage)")
        #endif
        
        // Track critical events for monitoring
        if level == .critical || level == .error {
            trackError(level: level, category: category, message: message, file: fileName, function: function, line: line)
        }
    }
    
    // MARK: - Convenience Methods
    
    func debug(_ message: String, category: Category = .general, file: String = #file, function: String = #function, line: Int = #line) {
        log(.debug, category: category, message: message, file: file, function: function, line: line)
    }
    
    func info(_ message: String, category: Category = .general, file: String = #file, function: String = #function, line: Int = #line) {
        log(.info, category: category, message: message, file: file, function: function, line: line)
    }
    
    func warning(_ message: String, category: Category = .general, file: String = #file, function: String = #function, line: Int = #line) {
        log(.warning, category: category, message: message, file: file, function: function, line: line)
    }
    
    func error(_ message: String, category: Category = .general, file: String = #file, function: String = #function, line: Int = #line) {
        log(.error, category: category, message: message, file: file, function: function, line: line)
    }
    
    func critical(_ message: String, category: Category = .general, file: String = #file, function: String = #function, line: Int = #line) {
        log(.critical, category: category, message: message, file: file, function: function, line: line)
    }
    
    // MARK: - Error Tracking
    
    private func trackError(level: LogLevel, category: Category, message: String, file: String, function: String, line: Int) {
        let errorEvent = ErrorEvent(
            level: level.rawValue,
            category: category.rawValue,
            message: message,
            file: file,
            function: function,
            line: line,
            timestamp: Date(),
            deviceInfo: DeviceInfo.current
        )
        
        // Store for later analysis or send to monitoring service
        storeErrorEvent(errorEvent)
    }
    
    private func storeErrorEvent(_ event: ErrorEvent) {
        // In a real app, you'd send this to your monitoring service
        // For now, we'll store locally for development
        
        #if DEBUG
        print("üö® ERROR TRACKED: \(event)")
        #endif
        
        // TODO: Integrate with monitoring service like Sentry, Bugsnag, etc.
        // Example: Sentry.capture(error: event)
    }
    
    // MARK: - Performance Logging
    
    func measurePerformance<T>(_ operation: () throws -> T, operationName: String, category: Category = .performance) rethrows -> T {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        defer {
            let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
            let milliseconds = timeElapsed * 1000
            
            if milliseconds > 100 { // Log slow operations
                warning("Slow operation: \(operationName) took \(String(format: "%.2f", milliseconds))ms", category: category)
            } else {
                debug("Performance: \(operationName) took \(String(format: "%.2f", milliseconds))ms", category: category)
            }
        }
        
        return try operation()
    }
    
    // MARK: - Network Logging
    
    func logNetworkRequest(url: String, method: String, category: Category = .network) {
        debug("Network Request: \(method) \(url)", category: category)
    }
    
    func logNetworkResponse(url: String, statusCode: Int, responseTime: TimeInterval, category: Category = .network) {
        let message = "Network Response: \(url) - Status: \(statusCode), Time: \(String(format: "%.2f", responseTime * 1000))ms"
        
        if statusCode >= 400 {
            error(message, category: category)
        } else {
            debug(message, category: category)
        }
    }
    
    // MARK: - Security Logging
    
    func logSecurityEvent(_ event: SecurityEvent, category: Category = .security) {
        let message = "Security Event: \(event.type.rawValue) - \(event.description)"
        
        switch event.severity {
        case .low:
            info(message, category: category)
        case .medium:
            warning(message, category: category)
        case .high:
            error(message, category: category)
        case .critical:
            critical(message, category: category)
        }
    }
    
    // MARK: - User Action Logging (for analytics)
    
    func logUserAction(_ action: UserAction, category: Category = .ui) {
        let message = "User Action: \(action.name) - \(action.context ?? "No context")"
        info(message, category: category)
        
        // In a real app, you'd send this to your analytics service
        // Example: Analytics.track(action)
    }
}

// MARK: - Supporting Types

struct ErrorEvent {
    let level: String
    let category: String
    let message: String
    let file: String
    let function: String
    let line: Int
    let timestamp: Date
    let deviceInfo: DeviceInfo
    
    var dictionary: [String: Any] {
        return [
            "level": level,
            "category": category,
            "message": message,
            "file": file,
            "function": function,
            "line": line,
            "timestamp": ISO8601DateFormatter().string(from: timestamp),
            "device": deviceInfo.dictionary
        ]
    }
}

struct DeviceInfo {
    let model: String
    let systemVersion: String
    let appVersion: String
    let buildNumber: String
    
    static var current: DeviceInfo {
        return DeviceInfo(
            model: deviceModel(),
            systemVersion: ProcessInfo.processInfo.operatingSystemVersionString,
            appVersion: Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "Unknown",
            buildNumber: Bundle.main.infoDictionary?["CFBundleVersion"] as? String ?? "Unknown"
        )
    }
    
    var dictionary: [String: Any] {
        return [
            "model": model,
            "systemVersion": systemVersion,
            "appVersion": appVersion,
            "buildNumber": buildNumber
        ]
    }
    
    private static func deviceModel() -> String {
        var systemInfo = utsname()
        uname(&systemInfo)
        let machineMirror = Mirror(reflecting: systemInfo.machine)
        let identifier = machineMirror.children.reduce("") { identifier, element in
            guard let value = element.value as? Int8, value != 0 else { return identifier }
            return identifier + String(UnicodeScalar(UInt8(value))!)
        }
        return identifier.isEmpty ? "Unknown" : identifier
    }
}

enum SecurityEventType: String, CaseIterable {
    case authenticationAttempt = "authentication_attempt"
    case authenticationFailure = "authentication_failure"
    case unauthorizedAccess = "unauthorized_access"
    case suspiciousActivity = "suspicious_activity"
    case dataAccess = "data_access"
    case configurationChange = "configuration_change"
}

enum SecurityEventSeverity: String, CaseIterable {
    case low, medium, high, critical
}

struct SecurityEvent {
    let type: SecurityEventType
    let severity: SecurityEventSeverity
    let description: String
    let metadata: [String: Any]?
    
    init(type: SecurityEventType, severity: SecurityEventSeverity, description: String, metadata: [String: Any]? = nil) {
        self.type = type
        self.severity = severity
        self.description = description
        self.metadata = metadata
    }
}

struct UserAction {
    let name: String
    let context: String?
    let metadata: [String: Any]?
    
    init(name: String, context: String? = nil, metadata: [String: Any]? = nil) {
        self.name = name
        self.context = context
        self.metadata = metadata
    }
}

// MARK: - Global Logging Functions for Easy Use

func logDebug(_ message: String, category: LoggingService.Category = .general, file: String = #file, function: String = #function, line: Int = #line) {
    LoggingService.shared.debug(message, category: category, file: file, function: function, line: line)
}

func logInfo(_ message: String, category: LoggingService.Category = .general, file: String = #file, function: String = #function, line: Int = #line) {
    LoggingService.shared.info(message, category: category, file: file, function: function, line: line)
}

func logWarning(_ message: String, category: LoggingService.Category = .general, file: String = #file, function: String = #function, line: Int = #line) {
    LoggingService.shared.warning(message, category: category, file: file, function: function, line: line)
}

func logError(_ message: String, category: LoggingService.Category = .general, file: String = #file, function: String = #function, line: Int = #line) {
    LoggingService.shared.error(message, category: category, file: file, function: function, line: line)
}

func logCritical(_ message: String, category: LoggingService.Category = .general, file: String = #file, function: String = #function, line: Int = #line) {
    LoggingService.shared.critical(message, category: category, file: file, function: function, line: line)
}