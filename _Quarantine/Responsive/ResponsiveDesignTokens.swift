import SwiftUI

// MARK: - Responsive Design System
struct ResponsiveDesignTokens {
    
    // MARK: - Breakpoints
    enum ScreenSize {
        case compact    // iPhone SE, iPhone Mini
        case regular    // iPhone, iPhone Plus
        case large      // iPhone Pro Max, iPad Mini
        case extraLarge // iPad, iPad Pro
        
        static func current(for width: CGFloat) -> ScreenSize {
            switch width {
            case 0..<375: return .compact
            case 375..<414: return .regular
            case 414..<768: return .large
            default: return .extraLarge
            }
        }
        
        var isCompact: Bool {
            self == .compact
        }
        
        var isTablet: Bool {
            self == .extraLarge
        }
    }
    
    // MARK: - Responsive Spacing
    struct Spacing {
        let screenSize: ScreenSize
        
        var xxs: CGFloat { screenSize.isCompact ? 2 : 4 }
        var xs: CGFloat { screenSize.isCompact ? 4 : 8 }
        var sm: CGFloat { screenSize.isCompact ? 8 : 12 }
        var md: CGFloat { screenSize.isCompact ? 12 : 16 }
        var lg: CGFloat { screenSize.isCompact ? 16 : 20 }
        var xl: CGFloat { screenSize.isCompact ? 20 : 24 }
        var xxl: CGFloat { screenSize.isCompact ? 24 : 32 }
        
        // Semantic spacing
        var cardPadding: CGFloat { screenSize.isCompact ? 12 : 16 }
        var sectionSpacing: CGFloat { screenSize.isCompact ? 16 : 24 }
        var screenPadding: CGFloat { screenSize.isCompact ? 16 : 20 }
    }
    
    // MARK: - Responsive Typography
    struct Typography {
        let screenSize: ScreenSize
        
        var largeTitle: Font {\n            screenSize.isCompact ? .title : .largeTitle\n        }\n        \n        var title1: Font {\n            screenSize.isCompact ? .title2 : .title\n        }\n        \n        var title2: Font {\n            screenSize.isCompact ? .title3 : .title2\n        }\n        \n        var headline: Font {\n            screenSize.isCompact ? .subheadline : .headline\n        }\n        \n        var body: Font {\n            screenSize.isCompact ? .callout : .body\n        }\n        \n        var caption: Font {\n            screenSize.isCompact ? .caption2 : .caption\n        }\n        \n        // Chart-specific typography\n        var chartTitle: Font {\n            screenSize.isCompact ? .subheadline : .headline\n        }\n        \n        var chartAxisLabel: Font {\n            .caption2\n        }\n        \n        var chartTooltip: Font {\n            screenSize.isCompact ? .caption2 : .caption\n        }\n    }\n    \n    // MARK: - Responsive Dimensions\n    struct Dimensions {\n        let screenSize: ScreenSize\n        \n        var cornerRadius: CGFloat {\n            screenSize.isCompact ? 8 : 12\n        }\n        \n        var cardCornerRadius: CGFloat {\n            screenSize.isCompact ? 12 : 16\n        }\n        \n        var buttonHeight: CGFloat {\n            screenSize.isCompact ? 44 : 48\n        }\n        \n        var iconSize: CGFloat {\n            screenSize.isCompact ? 20 : 24\n        }\n        \n        var chartHeight: CGFloat {\n            screenSize.isCompact ? 180 : 220\n        }\n        \n        var miniChartHeight: CGFloat {\n            screenSize.isCompact ? 120 : 150\n        }\n        \n        var metricCardHeight: CGFloat {\n            screenSize.isCompact ? 100 : 120\n        }\n        \n        // Grid columns for different layouts\n        var dashboardColumns: Int {\n            switch screenSize {\n            case .compact: return 2\n            case .regular: return 2\n            case .large: return 3\n            case .extraLarge: return 4\n            }\n        }\n        \n        var chartGridColumns: Int {\n            switch screenSize {\n            case .compact: return 1\n            case .regular: return 2\n            case .large: return 2\n            case .extraLarge: return 3\n            }\n        }\n    }\n    \n    // MARK: - Animation Presets\n    struct Animations {\n        static let quickBounce = Animation.spring(response: 0.3, dampingFraction: 0.8)\n        static let smooth = Animation.easeInOut(duration: 0.3)\n        static let chartEntry = Animation.easeOut(duration: 0.8)\n        static let chartHighlight = Animation.spring(response: 0.2, dampingFraction: 0.9)\n        static let cardTap = Animation.spring(response: 0.1, dampingFraction: 0.8)\n    }\n    \n    // MARK: - Responsive Modifiers\n    struct Modifiers {\n        let screenSize: ScreenSize\n        \n        var cardShadow: some View {\n            EmptyView()\n                .shadow(\n                    color: .black.opacity(screenSize.isCompact ? 0.08 : 0.12),\n                    radius: screenSize.isCompact ? 4 : 8,\n                    x: 0,\n                    y: screenSize.isCompact ? 2 : 4\n                )\n        }\n        \n        var interactiveShadow: some View {\n            EmptyView()\n                .shadow(\n                    color: .black.opacity(0.15),\n                    radius: screenSize.isCompact ? 6 : 12,\n                    x: 0,\n                    y: screenSize.isCompact ? 3 : 6\n                )\n        }\n    }\n}\n\n// MARK: - Environment Key for Screen Size\nstruct ScreenSizeKey: EnvironmentKey {\n    static let defaultValue: ResponsiveDesignTokens.ScreenSize = .regular\n}\n\nextension EnvironmentValues {\n    var screenSize: ResponsiveDesignTokens.ScreenSize {\n        get { self[ScreenSizeKey.self] }\n        set { self[ScreenSizeKey.self] = newValue }\n    }\n}\n\n// MARK: - Responsive Layout Helpers\nstruct ResponsiveStack<Content: View>: View {\n    let screenSize: ResponsiveDesignTokens.ScreenSize\n    let spacing: CGFloat?\n    @ViewBuilder let content: () -> Content\n    \n    var body: some View {\n        if screenSize.isTablet {\n            HStack(spacing: spacing) {\n                content()\n            }\n        } else {\n            VStack(spacing: spacing) {\n                content()\n            }\n        }\n    }\n}\n\nstruct ResponsiveGrid<Content: View>: View {\n    let columns: Int\n    let spacing: CGFloat\n    @ViewBuilder let content: () -> Content\n    \n    private var gridColumns: [GridItem] {\n        Array(repeating: GridItem(.flexible(), spacing: spacing), count: columns)\n    }\n    \n    var body: some View {\n        LazyVGrid(columns: gridColumns, spacing: spacing) {\n            content()\n        }\n    }\n}\n\n// MARK: - Responsive Padding Modifier\nstruct ResponsivePadding: ViewModifier {\n    let screenSize: ResponsiveDesignTokens.ScreenSize\n    let base: CGFloat\n    \n    func body(content: Content) -> some View {\n        content\n            .padding(ResponsiveDesignTokens.Spacing(screenSize: screenSize).screenPadding)\n    }\n}\n\nextension View {\n    func responsivePadding(for screenSize: ResponsiveDesignTokens.ScreenSize, base: CGFloat = 16) -> some View {\n        modifier(ResponsivePadding(screenSize: screenSize, base: base))\n    }\n    \n    func responsiveCardStyle(for screenSize: ResponsiveDesignTokens.ScreenSize) -> some View {\n        let dimensions = ResponsiveDesignTokens.Dimensions(screenSize: screenSize)\n        let spacing = ResponsiveDesignTokens.Spacing(screenSize: screenSize)\n        \n        return self\n            .padding(spacing.cardPadding)\n            .background(Color.white)\n            .cornerRadius(dimensions.cardCornerRadius)\n            .shadow(\n                color: .black.opacity(screenSize.isCompact ? 0.08 : 0.12),\n                radius: screenSize.isCompact ? 4 : 8,\n                x: 0,\n                y: screenSize.isCompact ? 2 : 4\n            )\n    }\n}\n\n// MARK: - Responsive Chart Configuration\nstruct ResponsiveChartConfig {\n    let screenSize: ResponsiveDesignTokens.ScreenSize\n    \n    var height: CGFloat {\n        ResponsiveDesignTokens.Dimensions(screenSize: screenSize).chartHeight\n    }\n    \n    var miniHeight: CGFloat {\n        ResponsiveDesignTokens.Dimensions(screenSize: screenSize).miniChartHeight\n    }\n    \n    var axisLabelFont: Font {\n        ResponsiveDesignTokens.Typography(screenSize: screenSize).chartAxisLabel\n    }\n    \n    var titleFont: Font {\n        ResponsiveDesignTokens.Typography(screenSize: screenSize).chartTitle\n    }\n    \n    var showDetailedLabels: Bool {\n        !screenSize.isCompact\n    }\n    \n    var lineWidth: CGFloat {\n        screenSize.isCompact ? 2 : 3\n    }\n    \n    var pointSize: CGFloat {\n        screenSize.isCompact ? 20 : 30\n    }\n}\n\n// MARK: - Device Orientation Helper\nclass DeviceOrientationManager: ObservableObject {\n    @Published var orientation: UIDeviceOrientation = UIDevice.current.orientation\n    @Published var screenSize: ResponsiveDesignTokens.ScreenSize = .regular\n    \n    init() {\n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(orientationDidChange),\n            name: UIDevice.orientationDidChangeNotification,\n            object: nil\n        )\n        updateScreenSize()\n    }\n    \n    @objc private func orientationDidChange() {\n        DispatchQueue.main.async {\n            self.orientation = UIDevice.current.orientation\n            self.updateScreenSize()\n        }\n    }\n    \n    private func updateScreenSize() {\n        let width = UIScreen.main.bounds.width\n        screenSize = ResponsiveDesignTokens.ScreenSize.current(for: width)\n    }\n}\n\n// MARK: - Preview Helpers\nstruct ResponsivePreview<Content: View>: View {\n    @ViewBuilder let content: () -> Content\n    \n    var body: some View {\n        Group {\n            // Compact iPhone (iPhone SE)\n            content()\n                .environment(\\.screenSize, .compact)\n                .previewDevice(\"iPhone SE (3rd generation)\")\n                .previewDisplayName(\"Compact\")\n            \n            // Regular iPhone\n            content()\n                .environment(\\.screenSize, .regular)\n                .previewDevice(\"iPhone 14\")\n                .previewDisplayName(\"Regular\")\n            \n            // Large iPhone\n            content()\n                .environment(\\.screenSize, .large)\n                .previewDevice(\"iPhone 14 Pro Max\")\n                .previewDisplayName(\"Large\")\n            \n            // iPad\n            content()\n                .environment(\\.screenSize, .extraLarge)\n                .previewDevice(\"iPad (10th generation)\")\n                .previewDisplayName(\"Tablet\")\n        }\n    }\n}\n\n// MARK: - Usage Examples in Comments\n/*\n // Example 1: Using responsive spacing\n VStack(spacing: ResponsiveDesignTokens.Spacing(screenSize: screenSize).md) {\n     // content\n }\n \n // Example 2: Using responsive typography\n Text(\"Title\")\n     .font(ResponsiveDesignTokens.Typography(screenSize: screenSize).headline)\n \n // Example 3: Using responsive grid\n ResponsiveGrid(columns: ResponsiveDesignTokens.Dimensions(screenSize: screenSize).dashboardColumns, spacing: 16) {\n     // grid items\n }\n \n // Example 4: Using responsive card style\n VStack {\n     // content\n }\n .responsiveCardStyle(for: screenSize)\n \n // Example 5: Using responsive chart config\n let chartConfig = ResponsiveChartConfig(screenSize: screenSize)\n Chart(data) { item in\n     LineMark(...)\n         .lineStyle(StrokeStyle(lineWidth: chartConfig.lineWidth))\n }\n .frame(height: chartConfig.height)\n */\n\n#Preview {\n    ResponsivePreview {\n        VStack {\n            Text(\"Responsive Design Tokens\")\n                .font(.title)\n            Text(\"This preview shows different screen sizes\")\n                .font(.caption)\n        }\n        .padding()\n    }\n}"